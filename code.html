<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive CTF Toolkit - All-in-One Web-Based Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .tool-section { border: 1px solid #e5e7eb; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem; background-color: #f9fafb; }
        .tool-title { font-size: 1.25rem; font-weight: bold; margin-bottom: 1rem; }
        textarea, input { width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 4px; margin-bottom: 1rem; }
        button { background-color: #3b82f6; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #2563eb; }
        #output { margin-top: 1rem; padding: 1rem; background-color: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; white-space: pre-wrap; }
        .nav-link { color: #3b82f6; cursor: pointer; margin: 0 1rem; }
        .nav-link:hover { text-decoration: underline; }
        @media (max-width: 768px) { .tool-section { padding: 1rem; } }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
    <header class="w-full max-w-4xl mb-8">
        <div class="hero-image mb-6">
            <img src="https://storage.googleapis.com/workspace-0f70711f-8b4e-4d94-86f1-2a93ccde5887/image/480dc663-0b66-4844-b1a1-840a2ac7f568.png" alt="Futuristic digital interface with glowing binary code streams, cryptographic symbols like locks and keys, network graphs, and abstract representations of hacking tools in a dark blue and neon green color scheme, composed in a high-tech cyberpunk style with depth and particle effects" onerror="this.onerror=null; this.src='https://storage.googleapis.com/workspace-0f70711f-8b4e-4d94-86f1-2a93ccde5887/image/d0e3364e-3a26-4ac9-b1c8-451bb1e306b3.png'; this.alt='Fallback image: Abstract cyber security toolkit representation';" class="w-full h-auto">
        </div>
        <h1 class="text-3xl font-bold text-center mb-4">Comprehensive CTF Toolkit</h1>
        <p class="text-center text-gray-600 mb-6">A single-page web-based collection of essential Capture The Flag (CTF) tools for crypto, encoding, hashing, and more. Built with HTML, CSS, and JavaScript for easy use. All tools are client-side and responsive.</p>
        <nav class="flex justify-center flex-wrap mb-4">
            <span class="nav-link" onclick="scrollToSection('crypto')">Crypto Tools</span>
            <span class="nav-link" onclick="scrollToSection('encoding')">Encoding/Decoding</span>
            <span class="nav-link" onclick="scrollToSection('hashing')">Hashing</span>
            <span class="nav-link" onclick="scrollToSection('misc')">Miscellaneous</span>
        </nav>
    </header>

    <main class="w-full max-w-4xl space-y-8">
        <!-- Crypto Tools Section -->
        <section id="crypto" class="tool-section">
            <h2 class="tool-title">Crypto Tools</h2>
            
            <!-- Caesar Cipher Solver -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2">Caesar Cipher Solver</h3>
                <textarea id="caesarInput" placeholder="Enter ciphertext"></textarea>
                <button onclick="solveCaesar()">Solve</button>
                <div id="caesarOutput" class="output"></div>
            </div>
            
            <!-- ROT13 Decoder -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2">ROT13 Decoder</h3>
                <textarea id="rot13Input" placeholder="Enter text"></textarea>
                <button onclick="decodeRot13()">Decode/Encode</button>
                <div id="rot13Output" class="output"></div>
            </div>
            
            <!-- XOR Brute Force -->
            <div>
                <h3 class="text-lg font-semibold mb-2">XOR Brute Force (Single Byte Key)</h3>
                <textarea id="xorInput" placeholder="Enter hex string (e.g., 1a2b3c)"></textarea>
                <button onclick="bruteXor()">Brute Force</button>
                <div id="xorOutput" class="output"></div>
            </div>
        </section>

        <!-- Encoding/Decoding Section -->
        <section id="encoding" class="tool-section">
            <h2 class="tool-title">Encoding/Decoding Tools</h2>
            
            <!-- Base64 Encoder/Decoder -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2">Base64 Encoder/Decoder</h3>
                <textarea id="base64Input" placeholder="Enter text"></textarea>
                <button onclick="encodeBase64()">Encode</button>
                <button onclick="decodeBase64()">Decode</button>
                <div id="base64Output" class="output"></div>
            </div>
            
            <!-- URL Encoder/Decoder -->
            <div>
                <h3 class="text-lg font-semibold mb-2">URL Encoder/Decoder</h3>
                <textarea id="urlInput" placeholder="Enter URL or text"></textarea>
                <button onclick="encodeUrl()">Encode</button>
                <button onclick="decodeUrl()">Decode</button>
                <div id="urlOutput" class="output"></div>
            </div>
        </section>

        <!-- Hashing Section -->
        <section id="hashing" class="tool-section">
            <h2 class="tool-title">Hashing Tools</h2>
            
            <!-- MD5 Hash -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2">MD5 Hash Generator</h3>
                <textarea id="md5Input" placeholder="Enter text"></textarea>
                <button onclick="generateMd5()">Generate</button>
                <div id="md5Output" class="output"></div>
            </div>
            
            <!-- SHA-256 Hash -->
            <div>
                <h3 class="text-lg font-semibold mb-2">SHA-256 Hash Generator</h3>
                <textarea id="sha256Input" placeholder="Enter text"></textarea>
                <button onclick="generateSha256()">Generate</button>
                <div id="sha256Output" class="output"></div>
            </div>
        </section>

        <!-- Miscellaneous Section -->
        <section id="misc" class="tool-section">
            <h2 class="tool-title">Miscellaneous Tools</h2>
            
            <!-- Hex to ASCII -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2">Hex to ASCII Converter</h3>
                <textarea id="hexInput" placeholder="Enter hex string (e.g., 48656c6c6f)"></textarea>
                <button onclick="hexToAscii()">Convert</button>
                <div id="hexOutput" class="output"></div>
            </div>
            
            <!-- ASCII to Hex -->
            <div>
                <h3 class="text-lg font-semibold mb-2">ASCII to Hex Converter</h3>
                <textarea id="asciiInput" placeholder="Enter text"></textarea>
                <button onclick="asciiToHex()">Convert</button>
                <div id="asciiOutput" class="output"></div>
            </div>
        </section>
    </main>

    <footer class="w-full max-w-4xl mt-8 text-center text-gray-500">
        <p>CTF Toolkit v1.0 - For educational purposes only. Use responsibly.</p>
        <div class="footer-image mt-4">
            <img src="https://storage.googleapis.com/workspace-0f70711f-8b4e-4d94-86f1-2a93ccde5887/image/5d8761af-5e30-4c71-9594-3dc64acf5879.png" alt="Symbolic representation of a flag capture in CTF, showing a digital flag waving on a pole with binary code rain in the background, in red and blue tones with a triumphant composition and subtle glow effects" onerror="this.onerror=null; this.src='https://storage.googleapis.com/workspace-0f70711f-8b4e-4d94-86f1-2a93ccde5887/image/24b262ce-56f0-47e5-8630-9689c02f1e50.png'; this.alt='Fallback image: CTF flag symbol';">
        </div>
    </footer>

    <script>
        function scrollToSection(id) {
            document.getElementById(id).scrollIntoView({ behavior: 'smooth' });
        }

        // Caesar Cipher
        function solveCaesar() {
            const input = document.getElementById('caesarInput').value;
            let output = '';
            for (let shift = 0; shift < 26; shift++) {
                let result = '';
                for (let char of input) {
                    if (char.match(/[a-z]/i)) {
                        const code = char.charCodeAt(0);
                        const base = char.toLowerCase() === char ? 97 : 65;
                        result += String.fromCharCode((code - base - shift + 26) % 26 + base);
                    } else {
                        result += char;
                    }
                }
                output += `Shift ${shift}: ${result}\n`;
            }
            document.getElementById('caesarOutput').innerText = output;
        }

        // ROT13
        function decodeRot13() {
            const input = document.getElementById('rot13Input').value;
            let result = '';
            for (let char of input) {
                if (char.match(/[a-z]/i)) {
                    const code = char.charCodeAt(0);
                    const base = char.toLowerCase() === char ? 97 : 65;
                    result += String.fromCharCode((code - base + 13) % 26 + base);
                } else {
                    result += char;
                }
            }
            document.getElementById('rot13Output').innerText = result;
        }

        // XOR Brute Force
        function bruteXor() {
            const input = document.getElementById('xorInput').value.replace(/\s/g, '');
            const bytes = [];
            for (let i = 0; i < input.length; i += 2) {
                bytes.push(parseInt(input.substr(i, 2), 16));
            }
            let output = '';
            for (let key = 0; key < 256; key++) {
                let result = bytes.map(b => String.fromCharCode(b ^ key)).join('');
                if (result.match(/^[ -~]+$/)) { // Printable ASCII
                    output += `Key ${key.toString(16).padStart(2, '0')}: ${result}\n`;
                }
            }
            document.getElementById('xorOutput').innerText = output || 'No printable results found.';
        }

        // Base64
        function encodeBase64() {
            const input = document.getElementById('base64Input').value;
            document.getElementById('base64Output').innerText = btoa(input);
        }
        function decodeBase64() {
            const input = document.getElementById('base64Input').value;
            try {
                document.getElementById('base64Output').innerText = atob(input);
            } catch (e) {
                document.getElementById('base64Output').innerText = 'Invalid Base64';
            }
        }

        // URL
        function encodeUrl() {
            const input = document.getElementById('urlInput').value;
            document.getElementById('urlOutput').innerText = encodeURIComponent(input);
        }
        function decodeUrl() {
            const input = document.getElementById('urlInput').value;
            document.getElementById('urlOutput').innerText = decodeURIComponent(input);
        }

        // MD5 (Simple JS implementation)
        function generateMd5() {
            const input = document.getElementById('md5Input').value;
            document.getElementById('md5Output').innerText = md5(input); // md5 function below
        }
        function md5(s) {
            // Simplified MD5 (not cryptographically secure, for demo)
            function rotateLeft(lValue, iShiftBits) { return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits)); }
            function addUnsigned(lX, lY) {
                let lX4 = (lX & 0x40000000), lY4 = (lY & 0x40000000), lX8 = (lX & 0x80000000), lY8 = (lY & 0x80000000);
                let lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                if (lX4 | lY4) return (lResult & 0x40000000) ? (lResult ^ 0xC0000000 ^ lX8 ^ lY8) : (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                return (lResult ^ lX8 ^ lY8);
            }
            function F(x, y, z) { return (x & y) | ((~x) & z); }
            function G(x, y, z) { return (x & z) | (y & (~z)); }
            function H(x, y, z) { return (x ^ y ^ z); }
            function I(x, y, z) { return (y ^ (x | (~z))); }
            function FF(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }
            function GG(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }
            function HH(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }
            function II(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }
            function convertToWordArray(s) {
                let lWordCount, lMessageLength = s.length, lNumberOfWords_temp1 = lMessageLength + 8, lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                let lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16, lWordArray = Array(lNumberOfWords - 1), lBytePosition = 0, lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (s.charCodeAt(lByteCount) << lBytePosition)); lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition); lWordArray[lNumberOfWords - 2] = lMessageLength << 3; lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            }
            function wordToHex(lValue) {
                let wordToHexValue = "", wordToHexValue_temp = "", lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255; wordToHexValue_temp = "0" + lByte.toString(16); wordToHexValue += wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
                }
                return wordToHexValue;
            }
            let x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9, S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21;
            s = unescape(encodeURIComponent(s)); x = convertToWordArray(s); a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
            for (k = 0; k < x.length; k += 16) {
                AA = a; BB = b; CC = c; DD = d;
                a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478); d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756); c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB); b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF); d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A); c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613); b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8); d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF); c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1); b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122); d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193); c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E); b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562); d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340); c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51); b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D); d = GG(d, a, b, c, x[k + 10], S22, 0x2441453); c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681); b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6); d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6); c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87); b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905); d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8); c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9); b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942); d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681); c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122); b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44); d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9); c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60); b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6); d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA); c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085); b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039); d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5); c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8); b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = II(a, b, c, d, x[k + 0], S41, 0xF4292244); d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97); c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7); b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3); d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92); c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D); b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F); d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0); c = II(c, d, a, b, x[k + 6], S43, 0xA3014314); b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82); d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235); c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB); b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = addUnsigned(a, AA); b = addUnsigned(b, BB); c = addUnsigned(c, CC); d = addUnsigned(d, DD);
            }
            return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
        }

        // SHA-256 (Using Web Crypto API for accuracy)
        async function generateSha256() {
            const input = document.getElementById('sha256Input').value;
            const msgBuffer = new TextEncoder().encode(input);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('sha256Output').innerText = hashHex;
        }

        // Hex to ASCII
        function hexToAscii() {
            const input = document.getElementById('hexInput').value.replace(/\s/g, '');
            let result = '';
            for (let i = 0; i < input.length; i += 2) {
                result += String.fromCharCode(parseInt(input.substr(i, 2), 16));
            }
            document.getElementById('hexOutput').innerText = result;
        }

        // ASCII to Hex
        function asciiToHex() {
            const input = document.getElementById('asciiInput').value;
            let result = '';
            for (let char of input) {
                result += char.charCodeAt(0).toString(16).padStart(2, '0');
            }
            document.getElementById('asciiOutput').innerText = result;
        }
    </script>
</body>
</html>

